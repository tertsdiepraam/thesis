\chapter{Conclusion}\label{chap:conclusion}

We have presented a language specification based on hefty algebras. This specification includes the syntax definition, typing judgements and reduction semantics. Our focus in this endeavour was to show the viability and explore the ergonomics of such a language. The result is, in our opinion, a language in which higher-order effects can be represented with relative ease.

Additionally, we introduced implicit elaboration resolution, which reduces the syntactic overhead of elaborations. Of particular interest is how this feature interacts with the module system for any language, to allow effects to be imported along with their elaborations.

The prototype implementing this specification allowed us to create a set of example programs available in \cref{chap:examples} and in the artifact, which show off various applications of elaborations.

\section{Future Work}

Because Elaine's \el{elab} does not require all elaboration to be applied at once, the denotational semantics of Elaine are unclear. We conjecture that the semantics of expressions in Elaine are hefty trees, but we have no proof for this claim. This is a gap that could be filled by future work.

A missing feature in Elaine is type parameters for effects. In Koka, for example, the state effect \code{state<s>} is parametrized by a type \code{s}, which is not possible in Elaine. Another omission are IO operations. An Elaine program cannot write to files, accept input or print text apart from the value it returns. Furthermore, Elaine does not include any extensions of algebraic effects, such as named handlers. 

The prototype for Elaine only features an interpreter, not a compiler. So, another direction for future work is towards efficient compilation of elaborations. Since compilation of algebraic effects is well-established \autocite{leijen_type_2017}, a transformation from a program with elaborations to a program that only uses algebraic effects should enable full compilation of program with higher-order effects.
