% Let's figure this out
%
% We have several things to discuss here. The main focus should be on higher-order effects and elaborations,
% naturally. Then we just construct a knowledge dependency graph:
%
%                          monads
%                            |
%                    algebraic theory? (The question is how far back do we go?)
%                            |
%                    algebraic effects
%                   /               \
%   algebraicity property            \
%            |                        \
%   higher-order effects           Hefty algebras (in another chapter)
%                     \            /
%                      elaborations (in another chapter)

\chapter{Algebraic Effects}\label{chap:algebraic_effects}

Elaine is based on the theory of hefty algebras, which is an extension of the theory of algebraic effects. Hence, to discuss higher-order effects, we first give an introduction to algebraic effects. Readers familiar with algebraic effects may want to skip this chapter.

Algebraic effects have emerged as another model for effects. In this model, effects are treated as \emph{algebraic theories}.

\section{Monads}

\TODO{Introduce monads}

% What is a monad?
% - Kleisli triple
% - Resumable thingy? I.e. thennable
% - Computation as a data type

Monads are the canonical way to deal with effects in functional programming. The difficulty with effects in functional languages is that these languages usually require that all functions are pure. A function can therefore not, for example, arbitrarily modify some global value. The way then to encode effectful computation is similar to perform part of the computation and yield to an outer function, which performs the effect and then continues the computation.

A monad is the name for the class of types that enable this abstraction. These types represent either a finished computation returning a single value or a computation that has yielded on some operation and can be continued. Monads are then handled by some function which consumes the monad and return a value. These functions typically keep calling the continuation of the monad while possible and then return the final value. For this outer function, the operations encoded in the monad are not effectful, since it handles the effect only within its own scope. Therefore it does not violate the purity constraints that functional languages impose.

\TODO{Bwaaa I can't handle monads right now}
\begin{lstlisting}
newtype State s a = State { runState :: s -> (a, s) }

instance Monad (State s) where
    return a = State $ \s -> (a, s)
    m >>= k = State $ \s -> let (a, s') = runState m s
                         in runState (k a) s'

get :: State s s
get = State $ \s -> (s,s)

put :: s -> State s ()
put s = State $ \_ -> (s,())
\end{lstlisting}

To discuss effects, we introduce several example effects as they are commonly defined in the Haskell ecosystem. In particular, we base their definition on the mtl library of monads and monad transformers.

\TODO{Make better}
First, there is the \el{State} monad, which has two operations: \el{get} and \el{put}. These operations read and modify a values throughout the computation. The \el{get} operation takes no arguments and returns the value and \el{put} stores the value and returns the unit value.

The \el{Reader} monad is also meant to read some global value which can be retrieved with the \el{ask} operation, however, that value cannot be modified. A modified value can be scoped to a part of the computation with the \el{local} operation. This operation takes a computation and a function and when \el{ask} is used within the computation, the value is modified with the given function.

The \el{Exception} effect is for throwing and catching exceptions, much like in languages like Python and Java. The \el{throw} operation will halt execution and return to the innermost \el{catch} operation in which it is evaluated.

\section{Algebraic Theories}

This section introduces algebraic theories. In particular, we will discuss algebraic theories with parametrized operations and general arities. This forms a foundation on which we can define algebraic effects. For a more complete introduction to algebraic theories, we refer to \textcite{bauer_what_2018}.

An algebraic theory is a structure that we can impose on values and operations. We impose this structure only using equations. That is, using a expression of the form $a = b$, which is imposing that both sides of the equation must be equivalent. The set of equations is called the signature of the algebraic theory.

For example, we can define the suggestively-named operations \code{mul} with arity 2, \code{inv} with arity 1 and \code{zero} with arity 0. We can then build a collection of equations that specify the behaviour of these operations. If we want them to behave like a group, we need the laws of associativity, identity and inverse:
\begin{align*}
    \el{add(x, add(y, z))} &= \el{add(add(x, y), z)} \\
    \el{add(x, zero())} &= \el{x} \\
    \el{add(x, inv(x))} &= \el{zero()} \\
    \el{add(inv(x), x)} &= \el{zero()}
\end{align*}
With these operations, arities and equations, the algebraic theory then forms the theory a group. However, it is not itself a group, because an algebraic theory is hollow; it is only a specification. The implementation or meaning of the operations that we apply to the operation symbols needs to be given via an interpretation. That is, they need to be given associated functions that define their implementation. We call this interpretation a \emph{model} of the theory.

For instance, a model of the algebraic theory above is the ``obvious'' interpretation where we interpret values as numbers. We then treat \ozero as the number $0$, \oadd as the numeric addition and \oinv as numeric negation. Now we can check our equations. The third equation for instance gives us that for any number $x$,
\[
    \el{add(x, inv(x))} = x + (-x) = x - x = 0 = \el{zero()},
\]
and thus our model satisfies the equation. The same thing can be done with the other equation to verify that the model satisfies the theory.

Crucially, we can create a \emph{free model} for any algebraic theory for which a valid model exists. This free model is constructed by interpreting the operations as a tree where the arguments to an operation are its children in the tree. In programming language terminology, we are interpreting the operations as an abstract syntax tree. In such a model, the equations hold by definition.

\section{Notation for Computations}

The example from the previous section already looks somewhat like a programming language with only pure functions. While this is technically sufficient to write our programs in a continuation-passing style, we introduce some additional notation for convience. The notation from this point onward will match Elaine's syntax unless mentioned otherwise.

First, we write a semicolon to sequence operations, such that they are evaluated in order. Second, we introduce \el{let} bindings to store the result of an operation in a variable for later use.

As an example, take the \el{State} effect. To use this effect, we need two operations: \el{put} and \el{get}. The computation
\begin{center}
\el{put(a); get()}
\end{center}
then first performs the \oput operation and then the \oget operation, returning the result of the \oget operation.

For another example, we can sequence some operations with some \el{let} bindings inbetween:
\begin{center}
    \el{put(a); let x = get(); put(b); let y = get(); get()}
\end{center}

Naturally, this computation is nonsensical, but that is only because have not introduced any interesting operations yet! When we extend our little language with more operations, we will be able to express more interesting programs.

\section{Effects as Algebraic Theories}

\textcite{goos_adequacy_2001} have shown that many effects can be represented as algebraic theories. To do so, we have to define a signature and a set of equations for a given effect.

We start by again looking at the \el{State} effect. The equations that \el{State} should satisfy are the following:
\begin{align*}
    \el{let s = get(); let t = get(); k(s, t)}
        &\quad=\quad \el{let s = get(); k(s, s)} \\
    \el{let s = get(); put(s); k()} &\quad=\quad \el{k()} \\
    \el{put(s); let t = get(); k(t)} &\quad=\quad \el{put(s); k(s)} \\
    \el{put(s); put(t); k()} &\quad=\quad \el{put(t); k()}
\end{align*}
Here, \el{k} is some function representing the rest of the computation.

This gives us an algebraic theory corresponding to the \el{State} monad. \textcite{goos_adequacy_2001} have shown that this theory gives rise to the canonical \el{State} monad. Many other effects can also be represented as algebraic theories, including but not limited to, non-determinism, iteration, cooperative asynchronicity, traversal, input and output\citationneeded. These effects are called \emph{algebraic effects}.

An essential property of algebraic effects is that they can be composed. If we have two effects with disjoint operations and equations, we can construct a new effect which has the operations and equations of both effects. For algebraic effects \el{A} and \el{B}, we will write the composed effect as \el{<A,B>}. Note that the order here does not matter, since there is no significant order in both the operations or the equations. Therefore, \el{<A,B>} is equivalent to \el{<B,A>}.

We can extend this notation to any number of effects since the composition is associative as well. This gives us the notion of \emph{effect rows}: order-independent sets of effects. In this notation, \el{<>} is the empty effect row.

\section{Higher-Order Effects}

An effect is algebraic if its operations are algebraic. As shown by \textcite{plotkin_algebraic_2003}, an effect operation is algebraic if and only if it satisfies the \emph{algebraicity property}, which can be expressed as follows when \el{m1, ..., mN} are computation parameters:

\begin{center}
\begin{minipage}{0.4\textwidth}
    \begin{lstlisting}
{
    let x = op(m1, ..., mN);
    k
}
    \end{lstlisting}
\end{minipage}
$\qquad\Longleftrightarrow\qquad$
\begin{minipage}{0.4\textwidth}
    \begin{lstlisting}
op(
    {let x = m1; k},
    ...,
    {let x = mN; k},
)
    \end{lstlisting}
}
\end{minipage}
\end{center}

Therefore, sequencing the continuation must distribute over the operations of algebraic effects. This effectively means that any operation has to assume that its computation parameters will execute the entire remainder of the computation. In other words, the parameters are \emph{computation-like}.

A simple effect for which the algebraicity property does not hold is the \el{Reader} monad with the \el{local} and \el{ask} operations. The intended effect is that \el{local} applies some transformation \el{f} to the value retrieved with \el{ask} within the computation \el{m}, but not outside \el{m}. Therefore, we have that
\TODO{Format nicely}
\[
    \el{let x = local(f, m); ask()} \quad\neq\quad \el{local(f, \{let x = m; ask()\})},
\]
and have to conclude that we cannot represent the \el{Reader} monad as an algebraic theory and the effect is not algebraic.

A similar argument goes for the \el{Exception} effect. The \el{catch} operation takes two computation parameters, it executes the first and jumps to the second on encountering the \el{throw} operation. The problem arises when we bind with an \el{throw} operation:
\TODO{Format nicely}
\[
    \el{let x = catch(m1, m2); throw()} \quad\neq\quad \el{catch(\{let x = m1; throw()\}, \{let x = m2;throw()\})}.
\]
On the left-hand side, \el{m2} will not be executed if \el{m1} does not throw, while on the right-hand side, \el{m2} will always get executed. The two sides therefore have different semantics and hence the \el{catch} operation is not algebraic.

The distinction between effects which are and which are not algebraic has been described as the difference between \emph{effect constructors} and \emph{effect deconstructors} \autocite{plotkin_algebraic_2003}. The \el{local} and \el{catch} operations have to act on effectful computations and change the meaning of the effects in that computation. So, they have to deconstruct the effects in their computations.

\section{Effect Handlers}

\feedback[inline]{This needs to be expanded.}


\textcite{castagna_handlers_2009} introduced \emph{effect handlers} as a mechanism to allow for this deconstruction. Effect handlers are a generalization of exception handlers. They define the implementation for a set of algebraic operations in the sub-expression.

For example, we can define a handler for just the \oask operation, which is algebraic:
\[
    hAsk(v) = \handler \{
        \begin{aligned}[t]
            &\return(x) \mapsto x, \\
            &\oask()\ \kappa \mapsto \kappa(v) \}.\\
        \end{aligned}
\]

The \handle construct then applies a handler to an expression. For instance, the following computation with return with the value $5$:
\[
    \handle[hAsk(5)]\ \oask().
\]
With that handler we can give a definition of \olocal that has the intended behaviour:
\[
    \olocal(f, m) \quad\defeq\quad \S{x \gets \oask()\seq \handle[hAsk(f(x))]\ m}.
\]
However, \olocal cannot be defined as an algebraic operation, meaning that we cannot write a handler for it, it can only be defined as a handler. This is known as the \emph{modularity problem} with higher-order effects \autocite{wu_effect_2014}.

\section{Elaborations}\label{sec:elab}
\TODO{Move this somewhere else}

Several solutions to the modularity problem have been proposed \autocite{wu_effect_2014,oh_latent_2021}. Most recently, \textcite{bach_poulsen_hefty_2023} introduced hefty algebras. The idea behind hefty algebras is that there is an additional layer of modularity, specifically for higher-order effects. The higher-order operations are not algebraic, but they can be \emph{elaborated} into algebraic operations.

A computation with higher-order effects is then first elaborated into a computation with only algebraic effects. The remaining algebraic effects can then in turn be handled to yield the result of the computation.

The advantage of hefty algebras over previous approaches is that the elaboration step is quite simple\feedback{This needs explanation} and that the result is a computation with regular algebraic effects.

Continuing the \olocal example, we can make an elaboration based on the definition above\feedback{which definition?}:
\begin{align*}
    eLocal \quad\defeq\quad
        &\elaboration\ \{ \\
        &\quad\olocal!(f, m) \mapsto \S{v \gets \oask()\seq \handle[hAsk(f(v))]\ m }\\
        &\},
\end{align*}
We can then apply this elaboration to an expression with the \elab keyword\feedback{language we're working in is unclear}, similarly to \handle:
\begin{align*}
    &\handle[hAsk(5)]\ \elab[eLocal]\ \{ \\
    &\quad x \gets \oask();\\
    &\quad y \gets \olocal!(\lambda x.\ 2\cdot x, \S{ \oask() });\\
    &\quad x + y \\
    &\}
\end{align*}

After the elaboration step, the computation will be elaborated into the program below, which will evaluate to $15$.
\begin{align*}
    &\handle[hAsk(5)]\ \{ \\
    &\quad x \gets \oask();\\
    &\quad y \gets \{\\
    &\quad\quad v \gets \oask();\\
    &\quad\quad \handle[hAsk((\lambda x.\ 2\cdot x)(v))]\ \oask()\\
    &\quad\};\\
    &\quad x + y \\
    &\}
\end{align*}

Throughout this thesis we will write elaborated higher-order operations with a \code{!} suffix\feedback{give example}, to distinguish them from algebraic effects.

\TODO{Add some stuff about typing for effects, i.e. effect rows.}
