\chapter{A Tour of Elaine}\label{chap:basics}

The language designed for this thesis is called ``Elaine''. The distinguishing feature of this language is its support for higher-order effects via elaborations. The basic feature of elaborations has been extended with two novel features: implicit elaboration resolution and compilation of elaborations, which are explained in \cref{chap:elabres,chap:elabcomp}, respectively.

This chapter introduces Elaine with motivating examples for the design choices. The full specification is given in \cref{chap:spec}. More example programs are available in the artifact accompanying this thesis.\feedback{Overview of what can be found in the artifact.}

\section{Basics}

The design of Elaine is similar to Koka, with syntactical elements inspired by Rust. \fixme{Apart from the elaborations and handlers, it features let bindings, modules, if-else expressions, first-class functions, booleans, integers and strings.}

An Elaine program consists of a tree of modules. Top level declarations are part of the root module. The result of the program will be the value assigned to the \el{main} variable in the root module. A module is declared with \el{mod}, which takes a name and a block of declarations. Declarations can be marked as public with the \el{pub} keyword. A module's public declarations can be imported into another module with \el{use}.

The built-in primitives are \el{Int}, \el{Bool}, \el{String} and the unit \el{()}. The \el{std} module provides functions for basic manipulation of these primitives (e.g. \el{mul}, \el{lt} and \el{sub}). Functions are defined with \el{fn}, followed by a list of arguments and a function body. Functions are called with parentheses.

The type system features Hindley-Milner style type inference. Let bindings, function arguments and function return types can be given explicit types. By convention, we will write variables and modules in lowercase and capitalize types.

The language does not support recursion or any other looping construct.

\Cref{lst:square_is_even} contains a program that uses the basic features of Elaine and prints whether the square of 4 is even or odd. 

\example[caption={A simple Elaine program. The result of this program is the string \el{"The square of 4 is even"}.}]{square_is_even}

\section{Data Types}

\TODO{Write this section. Short version: we can define data types and match on the variants.}

\section{Algebraic Effects}

The programs in the previous section are all pure and contain no effects. Like the languages discussed in \cref{chap:related_work}, Elaine additionally has first class support for effects and effect handlers.

An effect is declared with the \el{effect} keyword. An effect needs a name and a set of operations. Operations are the functions that are associated with the effect. They can have an arbitrary number of arguments and a return type. Only the signature of operations can be given in an effect declaration, the implementation must be provided via handlers (see \cref{sec:alghandlers}).

\subsection{Effect Rows}

In Elaine, each type has an \emph{effect row}. In the previous examples, this effect row has been elided, but it is still inferred by the type checker. Effect rows specify the effects that need be handled to within the expression. For simple values, that effect row is empty, denoted \el{<>}. For example, an integer has type \el{<> Int}. Without row elision, the \el{square} function in the previous section could therefore have been written as

\begin{lstlisting}[language=elaine, style=fancy]
let square = fn(x: <> Int) <> Int {
    mul(x, x)
}
\end{lstlisting}

Simple effect rows consist of a list of effect names separated by commas. The return type of a function that returns an integer and uses effects \el{A} and \el{B} has type \el{<A,B> Int}. Important here is that this type is equivalent to \el{<B,A> Int}: the order of effects in effect rows is irrelevant. However, the multiplicity is important, that is, the effect rows \el{<A,A>} and \el{<A>} are not equivalent. To capture the equivalence between effect rows, we therefore model them as multisets.

Additionally, we can extend effect rows with other effect rows. In the syntax of the language, this is specified with the \el{|} at the end of the effect row: \el{<A,B|e>} means that the effect row contains \el{A}, \el{B} and some (possibly empty) set of remaining effects.

We can use extensions to ensure equivalence between effect rows without specifying the full rows (which might depend on context). For example, the following function uses the \el{Abort} effect if the called function returns false, while retaining the effects of the wrapped function.

\begin{lstlisting}[language=elaine, style=fancy]
let abort_on_false = fn(f: fn() <|e> Bool) <Abort|e> () {
    if f() { () } else { abort() }
}
\end{lstlisting}

Effect rows need special treatment in the unification algorithm of the type checker, which is detailed in \cref{sec:effectrows}.

\subsection{Effect Handlers}\label{sec:alghandlers}

To define the implementation of an effect, we have to define a handler it. Handlers are first-class values in Elaine and can be created with the \el{handler} keyword. They can then be applied to an expression with the \el{handle} keyword. When \el{handle} expressions are nested with handlers for the same effect, the innermost \el{handle} applies.

For example, if we want to use an effect to provide an implicit value, we can make an effect \el{Val} and a corresponding handler, which \el{resume}s execution with some values. The \el{resume} function represents the continuation of the program after the operation. Since handlers are first-class values, we can return the handler from a function to simplify the code. This pattern is quite common to create dynamic handlers with small variations.

\example[float=h]{val}

Calling the \el{resume} function is not required. All effect operations are executed by the \el{handle} expression, hence, if we return from the operation, we return from the \el{handle} expression.

The \el{Abort} effect is an example which does not call the continuation. It defines a single operation \el{abort}, which stops the evaluation of the computation. To show the modularity that the framework of algebraic effect handlers, provide we will demonstrate several possible handlers for \el{Abort}. First, we have the canonical handler for \el{Abort}, which returns the \el{Maybe} monad. If the computation returns, it returns the returned value wrapped in \el{Just}. If the computation aborts, it returns \el{Nothing()}.

\example[float=h,firstline=6]{abort}

Alternatively, we can define a handler that defines a default value for failing expressions. In this example, the handler acts much like an exception handler.

\example[float=h,firstline=7]{safe_division}

Finally, we can ignore \el{abort} calls if we are writing an application in which we always want to try to continue execution no matter what errors occur.\footnote{With a never type, an alternative definition of \el{Abort} is possible where this handler is not permitted by the type system. The signature of \el{abort} would then be \el{abort() !}, where \el{!} is the never type and then \el{resume} could not be called.}

\begin{lstlisting}[language=elaine,style=fancy]
let hAbort = handler {
    return(x) { x }
    abort() { resume(()) }
};
\end{lstlisting}

Just like we can ignore the continuation, we can also call it multiple times, which is useful for non-determinism and logic programming. \Cref{lst:logic} contains the full code for a (very naive) SAT solver in Elaine. We first define a \el{Yield} effect, so we can yield multiple values from the computation. We will use this to find all possible combinations of boolean inputs that satisfy the formula. The \el{Logic} effect has two operations. The \el{branch} operation will call the continuation twice; once with \el{false} and once \el{true}. With \el{fail}, we can indicate that a branch has failed. To find all solutions, we just \el{branch} on all inputs and \el{yield} when a correct solution has been found and \el{fail} when the formula is not satisfied. In \cref{lst:logic}, we check for solutions of the equation $\neg a \wedge b$.

\example[caption={A naive SAT solver in Elaine using algebraic effects to branch the execution.}]{logic}

\section{Higher-Order Effects}

\TODO{This section needs to be expanded a lot.}
\TODO{Figure out why \LaTeX wants to put all the listings at the end of the chapter.}

Higher-order effects in Elaine are supported via elaborations, as proposed by \textcite{bach_poulsen_hefty_2023}. To distinguish higher-order effects and operations from algebraic effects and operations, we write them with a \el{!} suffix. The higher-order operations differ from other functions and algebraic operations because they have call-by-name semantics; the arguments are not evaluated before they are passed to the elaboration. Hence, the arguments can be computations, even effectful computations.

Just like we have the \el{handler} and \el{handle} keywords to create and apply handlers for algebraic effects, we can create and apply elaborations with the \el{elaboration} and \el{elab} keywords. Unlike handlers, elaborations do not get access to the \el{resume} function, because they always resume exactly once.

This allows us to manipulate computations directly. For example, it is possible to wrap the computation in a handler within an elaboration.

\example[float,caption={Reader effect with higher-order \olocal operation in Elaine.}]{local_reader}

This is how higher-order operations such as \el{local} and \el{catch} are supported in Elaine.
