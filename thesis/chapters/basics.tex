\chapter{Elaine: Language Design}

\begin{itemize}
\item Begin with examples
\item Especially elaborations from HA paper
\item Explain relation between Elaine and Hefty Algebras
\item Spec
    \begin{itemize}
    \item Syntax
    \item Reduction semantics
    \item Typing rules \& row equivalence
    \item Type checker: unification rules mostly
    \end{itemize}
\end{itemize}

The language designed for this thesis is called ``Elaine". The distinguishing feature of this language is its support for higher-order effects via elaborations. It is not the first language with support for elaborations, with the first being Heft \citationneeded.

\todo{Put this somewhere}
\begin{lstlisting}[style=fancy]
mod math {
    use std;
    pub let double = fn(x) {
        mul(2, x)
    };
    pub let abs = fn(x) {
        if lt(x, 0) { sub(0, x) } else { x }
    };
}

use math;
let main = {
    let x = -10;
    let y = double(x);
    abs(doubled)
};
\end{lstlisting}
    
A module is declared with \el{mod}, which takes a name and a block of declarations. Each declaration prefixed with \el{pub} will be imported to other modules that reference this module. Modules cannot be nested. The built-in \el{std} module defines a few basic functions for boolean, integer and string manipulation (e.g. \el{mul}, \el{lt} and \el{sub}). Functions are defined anonymously with \el{fn}, followed by a list of argument, a return type and a function body. Functions are called with parentheses.

The design of Elaine is similar to Koka, with syntactical elements inspired by Rust. Apart from the elaborations and handlers, none of the language constructs should be particularly surprising: it has let bindings, if-else expressions, first-class functions, booleans, integers and strings. Below is a small sample program that prints whether the square of 4 is even or odd. For the full specification, we refer to \todo{add ref}.

For simplicity of analysis, the language does not support recursion or any other looping construct.

\begin{lstlisting}[language=elaine, style=fancy]
# The standard library contains basic functions for manipulation
# of integers, booleans and strings.
use std;

# Functions are created with `fn` and bound with `let`, just like
# other values. The last expression in a function is returned.
let square = fn(x: Int) Int {
    mul(x, x)
};

let is_even = fn(x: Int) Bool {
    eq(0, modulo(x, 2))
};

# Type annotations can be inferred:
let square_is_even = fn(x) {
    let result = is_even(square(x));
    if result {
        "even"
    } else {
        "odd"
    }
};

let give_answer = fn(f, x) {
    let text = concat(show_int(x), " is ");
    let answer = f(x);
    concat(text, answer)
};

let main = give_answer(square_is_even, 4);
\end{lstlisting}

\section{Algebraic Effects in Elaine}

The programs in the previous section are all pure and contain no effects and should be fairly standard. Following the lead of Koka\citationneeded, Elaine additionally has first class support for effects and effect handlers.

An effect is declared with the \el{effect} keyword. An effect needs a name and a set of operations. Operations are the functions that are associated with the effect. They can have an arbitrary number of arguments and a return type. Only the signature of operations can be given in an effect declaration, the implementation must be provided via handlers (see \cref{sec:alghandlers})

We will be using the following effects throughout this section.
\todo{Add corresponding monads?}
\begin{lstlisting}[language=elaine, style=fancy]
# Defines a single operation to get an implicit variable
effect Val {
    val() Int
}

# Exits the current handle
effect Abort {
    abort() ()
}

# Allows for a mutable state via a get and a set operation
effect State {
    get() Int
    set(Int) ()
}
\end{lstlisting}

\subsection{Effect Rows}

\todo[inline]{Contextual vs parametric effect rows (see effects as capabilities paper). The paper fails to really connect the two: contextual is just parametric with implicit variables. However, it might be more convenient. The main difference is in the interpretation of purity (real vs contextual). In general, I'd like to have a full section on effect row semantics. In the capabilities paper effect rows are sets, which makes it possible to do stuff like \autocite{leijen_extensible_2005}.}

In Elaine, each type has an \emph{effect row}. In the previous examples, this effect row has been elided, but it is still inferred by the type checker. Effect rows specify the effects that need be handled to within the expression. For simple values, that effect row is empty, denoted \el{<>}. For example, an integer has type \el{<> Int}. Without row elision, the \el{square} function in the previous section could therefore have been written as

\begin{lstlisting}[language=elaine, style=fancy]
let square = fn(x: <> Int) <> Int {
    mul(x, x)
}
\end{lstlisting}

Simple effect rows consist of a list of effect names separated by commas. The return type of a function that returns an integer and uses effects "A" and "B" has type \el{<A,B> Int}. Important here is that this type is equivalent to \el{<B,A> Int}: the order of effects in effect rows is irrelevant. However, the multiplicity is important, that is,  the effect rows \el{<A,A>} and \el{<A>} are not equivalent. To capture the equivalence between effect rows, we therefore model them as multisets.

Additionally, we can extend effect rows with other effect rows. In the syntax of the language, this is specified with the \el{|} at the end of the effect row: \el{<A,B|e>} means that the effect row contains \el{A}, \el{B} and some (possibly empty) other set of effects.

We can use extensions to ensure equivalence between effect rows without specifying the full rows (which might depend on context). For example, the following function uses the \el{Abort} effect if the called function returns false, while retaining the effects of the wrapped function.

\begin{lstlisting}[language=elaine, style=fancy]
let abort_on_false = fn(f: fn() <|e> Bool) <Abort|e> () {
    if f() { () } else { abort() }
}
\end{lstlisting}

Effect rows need special treatment in the unification algorithm of the type checker, which is detailed in \cref{sec:typechecker}.

\subsection{Effect Handlers}\label{sec:alghandlers}

To define the implementation of an effect, one has to create a handler for said effect. Handlers are first-class values in Elaine and can be created with the \el{handler} keyword. They can then be applied to an expression with the \el{handle} keyword. When \el{handle} expressions are nested with handlers for the same effect, the innermost \el{handle} applies.

For example, if we want to use an effect to provide an implicit value, we can make an effect \el{Val} and a corresponding handler, which \el{resume}s execution with some values. The \el{resume} function represents the continuation of the program after the operation. Since handlers are first-class values, we can return the handler from a function to simplify the code. This pattern is quite common to create dynamic handlers with small variations.

\begin{lstlisting}[language=elaine, style=fancy]
let hVal = fn(x) {
    handler Val {
        return(x) { x }
        val() { resume(x) }
    }
};

let main = {
    let a = handle[hVal(6)] add(val(), val());
    let b = handle[hVal(10)] add(val(), val());
    add(a, b)
};
\end{lstlisting}

The handlers we have introduced for \el{Val} all call the \el{resume} function, but that is not required. Conceptually, all effect operations are executed by the \el{handle}, hence, if we return from the operation, we return from the \el{handle}. A handler therefore has great control over control flow.

The \el{Abort} effect uses this mechanism. It defines a single operation \el{abort}, which returns from the handler without resuming. To show the flexibility that the framework of algebraic effect handlers, provide we will demonstrate several possible handlers for \el{Abort}. The first ignores the result of the computation, but still halts execution.

\begin{lstlisting}[language=elaine, style=fancy]
let hAbort = handler Abort {
    return(x) { () }
    abort() { () }
};

let main = {
    handle[hAbort] {
        abort();
        f()
    };
    g()
};
\end{lstlisting}

In the program above, \el{f} will not get called because \el{hAbort} does not call the continuation, but \el{g} will be called, because it is used outside of the \el{handle}.

Alternatively, we can define a handler that defines a default value for failing expressions.

\begin{lstlisting}[language=elaine, style=fancy]
let hAbort = fn(default) {
    handler Abort {
        return(x) { x }
        abort() { default }
    }
};

let safe_div = fn(x: Int, y: Int) <Abort> Int {
    if eq(y, 0) {
        abort()
    } else {
        div(x, y)
    }
};

let main = handle[hAbort] safe_div(5, 0);
\end{lstlisting}

We can also map the \el{Abort} effect to the \el{Maybe} monad, which is the most common implementation.

\todo[inline]{Even for small handlers I need custom data types}
\begin{lstlisting}[language=elaine, style=fancy]
let hAbort = handler Abort {
    return(x) { Just(x) }
    abort() { Nothing() }
};
\end{lstlisting}

Finally, we can ignore \el{abort} calls if we are writing an application in which we always want to try to continue execution no matter what errors occur.\footnote{With a never type, an alternative definition of \el{Abort} is possible where this handler is not permitted by the type system. The signature of \el{abort} would then be \el{abort() !}, where \el{!} is the never type and then \el{resume} could not be called.}

\begin{lstlisting}[language=elaine, style=fancy]
let hAbort = handler Abort {
    return(x) { x }
    abort() { resume(()) }
};
\end{lstlisting}

\section{Higher-Order Effects in Elaine}

\section{Specification of Elaine}
\subsection{Type Checker}\label{sec:typechecker}
\subsubsection{Unification of Effect Rows}

\todo[inline]{Talk about \autocite{leijen_extensible_2005}.}

During type checking effect rows are represented as a pair consisting of a multiset of effects and an optional extension variable. In this section we will use a more explicit notation than the syntax of the language by using the multiset representation directly. Hence, a row $\row{A_1,\dots,A_n|e_A}$ is represented as the multiset $\{A_1,\dots,A_n\} + e_A$.

Like with regular Hindley-Milner type inference, two rows can be unified if we can find a substitution of effect row variables that make the rows equal. For effect rows, this yields 3 distinct cases.

If both rows are closed (i.e. have no extension variable) there are no variables to be substituted and we just employ multiset equality. That is, to unify rows $A$ and $B$ we check that $A = B$. If that is true, we do not need to unify further and unification has succeeded. Otherwise, we cannot make any substitutions to make them equal and unification has failed.

If one of the rows is open, then the set of effects in that row need to be a subset of the effects in the other row. To unify the rows
\[ A + e_A \quad\text{and}\quad B \]
we assert that $A \subseteq B$. If that is true, we can substitute $e_n$ for the effects in $B - A$.

Finally, there is the case where both rows are open:
\[ A + e_A \quad\text{and}\quad B + e_B. \]
In this case, unification is always possible, because both rows can be extended with the effects of the other. We create a fresh effect row variable $e_C$ with the following substitutions:
\begin{align*}
    e_A &\to (B - A) + e_C \\
    e_B &\to (A - B) + e_C.
\end{align*}
In other words, $A$ is extended with the effects that are in $B$ but not in $A$ and similarly, $B$ is extended with the effects in $A$ but not in $A$.
