\chapter{Introduction}\label{chap:introduction}

As a program runs, it usually interacts with its environment. A function might, for example, allocate some memory, open a file or throw an exception. Apart from producing a value, such a procedure therefore also has some other observable \emph{effects} \autocite{moggi_computational_1989}.

The classical $\lambda$-calculus does not take these effects into account and models only \emph{pure} computations \autocite{moggi_computational_1989}. That is, computations which take some input and for every set of inputs they return the same output, without interacting with their environment. There is an elegance to this view, since pure programs are simple to reason about and analyse.

However, in practice, many programs are \emph{impure} or \emph{effectful}. As \textcite{moggi_computational_1989} notes, analysing only pure computation leaves out many aspects of programs, such as side effects, non-determinism and non-termination. Reasoning about the full behaviour of a program then necessarily needs to include an analysis of effects.

Some programming languages, such as C, give the programmer virtually unrestricted access to effectful operations. Any part of a C program can access memory and the filesystem and is even allowed to use \code{goto} to jump to any location in the code outside the structured control flow constructs. This unrestricted use has famously been criticized by \textcite{dijkstra_letters_1968}. In C (and similar languages), effects are also largely ignored in the type system. Programmers therefore have to rely on documentation and the source code to determine the side effects of any given function.

A challenge in language design is then to design a language which allows for (limited) impure calculation, while retaining the attractive qualities of pure languages. As a result, programming languages often have dedicated features for some effects, such as exceptions, coroutines and generators. While these features might seem very different on the surface, they have an important common property: they give away control to some other procedure and are handed back control later. This procedure could be a memory allocator, a scheduler, the kernel, an exception handler or something else that implements the necessary operations to perform the effect.

% spell-checker:ignore effekt
This insight is at the code of the theory of \emph{algebraic effects}, which unifies many effects into a single concept \autocite{goos_adequacy_2001,castagna_handlers_2009}. Here, effectful computations can only be used within \emph{effect handlers}, which the computation yields control to. A handler can then in turn call the continuation of the computation.

In recent years, some languages (e.g. Koka \autocite{leijen_koka_2014}, Eff \autocite{bauer_programming_2015}, Frank \autocite{lindley_be_2017}, and Effekt \autocite{brachthauser_effects_2020}) have been created with support for algebraic effects. These languages allow the programmer to define new effects without needing a dedicated language feature.

Moreover, these languages often feature type systems that can reason about the effects in each function. The programmer can therefore see from the signature what a function can do, such that effects act as capabilities \autocite{brachthauser_effects_2020}. Conversely, a library author might choose to only disallow (some) effects in some functions. For example, a hash function is generally understood to be deterministic and effectless, because it needs to be reproducible.

However, there are some commonly used effects that are not algebraic, namely \emph{higher-order effects}. That is, effects whose operations that take effectful computations as arguments that do not behave as continuations. To overcome this limitation, \textcite{bach_poulsen_hefty_2023} have extended algebraic effects with \emph{hefty algebras}, which introduces \emph{effect elaborations} to define higher-order effects.

In this thesis, we introduce a novel programming language called \emph{Elaine}. The core idea of Elaine is to define a language which features elaborations and higher-order effects as a first-class concept. This brings the theory of hefty algebras into practice. With Elaine, we aim to show the power of elaborations as a language feature. Throughout this thesis, we present example programs with higher-order effects to argue that elaborations are a natural and easy representation of higher-order effects.

Like handlers for algebraic effects, elaborations require the programmer to specify which elaboration should be applied. We argue that elaboration instead should often be implicit and inferred by the language. To this end, we introduce \emph{implicit elaboration resolution}, a novel feature that infers an elaboration from the context. This reduces the syntactic overhead of elaborations.

Finally, we give two transformations from higher-order effects to algebraic effects. There are two reasons for doing so. The first is to show how elaborations can be compiled in a larger compilation pipeline. The second is that these transformations show how elaborations could be added to existing systems for algebraic effects.

Elaine has a full specification with a syntax definition, typing judgments and reduction semantics. Along with this specification, we provide a full reference implementation of the language in Haskell\footnote{Available at \url{https://github.com/tertsdiepraam/thesis/tree/main/elaine}}. This implementation includes a parser, type checker, interpreter, pretty printer and the transformations mentioned above.

\section{Contributions}

The main contribution of this thesis is the specification and implementation of Elaine. This consists of several parts.

\begin{itemize}
    \item We define a syntax suitable for a language with both handlers and elaboration.
    \item We provide a set of examples for programming with higher-order effect operations.
    \item We present a type system for a language with higher-order effects and elaborations, based on Hindley-Milner type inference and the Koka type system. This type system introduces a novel representation of effect rows as multiset which, though semantically equivalent to earlier representations, allows for a simple definition of effect row unification.
    \item We propose that elaborations should be inferred in most cases and provide a type-directed scheme for this inference in \cref{chap:elabres}.
    \item We define 2 procedures for transforming programs with elaborations and higher-order effects to programs with only handlers and algebraic effects. The first transformation is convenient, but relies on impredicativity and therefore only works in languages that allow impredicativity, such as Elaine, Haskell and Koka. The second transformation is more involved, but does not rely on impredicativity and would therefore also be allowed in a language Agda.
\end{itemize}
