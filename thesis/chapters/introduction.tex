\chapter{Introduction}\label{chap:introduction}

As a program runs, it usually interacts with its environment. A program might, for example, allocate some memory, open a file or throw an exception. Apart from producing a value, such a procedure therefore also has some other observable \emph{effects} \autocite{moggi_computational_1989}.

\emph{Pure} functions are the computations which always return identical values for identical inputs and do not interact with their environment. While some programs can be viewed as pure, analysing only pure computation leaves out many aspects of programs, such as side effects, non-determinism and non-termination \autocite{moggi_computational_1989}. So, in practice, many programs are \emph{impure} or \emph{effectful}.

\fixme{We can extend this analysis to the type checker of a programming language. Such a type checker not only checks the types of values, but also the effects that a computation might have. This helps programmers reason about effects in a program.}\todo{Not sure where to put this and how to add more motivation.}

While many effects does not seem to have anything in common at first glance, they do share an important property: they yield control to some other procedure.\citationneeded This procedure, called an \emph{effect handler}, implements the necessary operations to perform the effect. An effect handler could be a memory allocator, a scheduler, a kernel, an exception handler or something else. Swapping out one effect handler for another then changes the semantics of the computation. This modularity of effect handlers is a powerful concept, allowing us to reuse computations within different contexts. For example, we might want to swap out one asynchronous runtime for another, or we could replace writing to \code{stdout} with writing to \code{stderr}.\todo{Better examples?}

Some programming languages opt to give the programmer virtually unrestricted access to effectful operations. For instance, any part of a C program can interact with memory, the filesystem or the network. The program can even yield control to any location with the \code{goto} keyword, which has famously been criticized by \textcite{dijkstra_letters_1968}. This ``anything goes'' approach puts a large burden of ensuring correct behaviour of effects on the programmer.

Many programming languages have done so by adding dedicated features for specific effects, such as exceptions, coroutines and generators. These features are useful, but they lack flexibility and modularity: any effect must be backed by the language and new effects cannot be created without adding a new feature to the language. It is also not usually possible to change the behaviour of these features.

A different approach is taken in many languages adhering to the functional programming paradigm: they choose to represent effects with monads. In theory, monads are a perfect representation for effects, since effects originally defined by \textcite{moggi_notions_1991} as monads. Yet, mathematical rigour does not make a practical programming language. In practice, monads suffer from a lack of modularity and flexibility.\citationneeded

This modularity is at the core of the theory of \emph{algebraic effects}, which unifies many common effects into a single concept \autocite{goos_adequacy_2001,castagna_handlers_2009}. In languages with algebraic effects, such as Koka \autocite{leijen_koka_2014}, Eff \autocite{bauer_programming_2015}, Frank \autocite{lindley_be_2017}, and Effekt \autocite{brachthauser_effects_2020}, effect handlers can be modularly defined within the language. The programmer can freely declare new effects and handlers. An effect here consists of a set of \emph{effect operations}, which yield control to their corresponding handler, which then performs the operation. The handler can resume the computation by calling the \emph{continuation}, which is a function that represents the rest of the computation. Moreover, these languages often feature type systems that can reason about the effects in each function. The programmer can therefore see from the signature what a function can do, such that effects act as capabilities \autocite{brachthauser_effects_2020}.

However, there are some commonly used effects that are not algebraic, namely \emph{higher-order effects}. That is, effect operations that take effectful computations as arguments that do not behave as continuations. Several approaches to modelling higher-order effects have been proposed \autocite{wu_effect_2014,oh_latent_2021}. Most recently, \textcite{bach_poulsen_hefty_2023} have proposed to extend algebraic effects with \emph{hefty algebras}, which introduces \emph{effect elaborations} to define higher-order effects. 

In this thesis, we introduce a novel programming language called \emph{Elaine}. The core idea of Elaine is to define a language which features elaborations and higher-order effects as a first-class construct. This brings the theory of hefty algebras into practice. With Elaine, we aim to demonstrate the usefulness of elaborations as a language feature. Throughout this thesis, we present example programs with higher-order effects to argue that elaborations are a natural and easy representation of higher-order effects.

Like handlers for algebraic effects, elaborations require the programmer to specify which elaboration should be applied. However, elaboration have several properties which make it likely that there is only one relevant possible elaboration. Hence, we argue that elaboration instead should often be implicit and inferred by the language. To this end, we introduce \emph{implicit elaboration resolution}, a novel feature that infers an elaboration from the variables in scope.

Finally, we give two transformations from higher-order effects to algebraic effects. There are two reasons for defining such a transformation. The first is to show how elaborations can be compiled in a larger compilation pipeline. The second is that these transformations show how elaborations could be added to existing systems for algebraic effects.

We present a specification for Elaine, including the syntax definition, typing judgments and semantics. Along with this specification, we provide a reference implementation written in Haskell in the artefact accompanying this thesis. This implementation includes a parser, type checker, interpreter, pretty printer, and the transformations mentioned above.

\section{Contributions}

The main contribution of this thesis is the specification and implementation of Elaine. This consists of several parts.

\begin{itemize}
    \item We define a syntax suitable for a language with both handlers and elaboration (\cref{sec:syntax}).
    \item We provide a set of examples for programming with higher-order effect operations.
    \item We present a type system for a language with higher-order effects and elaborations, based on Hindley-Milner type inference and inspired by the Koka type system. This type system introduces a novel representation of effect rows as multiset which, though semantically equivalent to earlier representations, allows for a simple definition of effect row unification.
    \item We propose that elaborations should be inferred in most cases and provide a type-directed procedure for this inference (\cref{chap:elabres}).
    \item We define two transformations form programs with elaborations and higher-order effects to programs with only handlers and algebraic effects. The first transformation is convenient, but relies on impredicativity and therefore only works in languages that allow impredicativity, such as Elaine, Haskell and Koka. The second transformation is more involved, but does not rely on impredicativity and would therefore also be allowed in a language like Agda.
\end{itemize}

\section{Artefact}

\TODO{Describe contents and structure of artefact}

The artefact is available online at \url{https://github.com/tertsdiepraam/thesis/elaine}.