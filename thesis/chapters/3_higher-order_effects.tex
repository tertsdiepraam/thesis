\chapter{Higher-Order Effects}\label{chap:higher_order}


\section{Higher-Order Effects}


A simple effect for which the algebraicity property does not hold is the \el{Reader} monad with the \el{local} and \el{ask} operations. The intended effect is that \el{local} applies some transformation \el{f} to the value retrieved with \el{ask} within the computation \el{m}, but not outside \el{m}. Therefore, we have that
\TODO{Format nicely}
\[
    \el{let x = local(f, m); ask()} \quad\neq\quad \el{local(f, \{let x = m; ask()\})},
\]
and have to conclude that we cannot represent the \el{Reader} monad as an algebraic theory and the effect is not algebraic.

A similar argument goes for the \el{Exception} effect. The \el{catch} operation takes two computation parameters, it executes the first and jumps to the second on encountering the \el{throw} operation. The problem arises when we bind with an \el{throw} operation:
\TODO{Format nicely}
\[
    \el{let x = catch(m1, m2); throw()} \quad\neq\quad \el{catch(\{let x = m1; throw()\}, \{let x = m2;throw()\})}.
\]
On the left-hand side, \el{m2} will not be executed if \el{m1} does not throw, while on the right-hand side, \el{m2} will always get executed. The two sides therefore have different semantics and hence the \el{catch} operation is not algebraic.

The distinction between effects which are and which are not algebraic has been described as the difference between \emph{effect constructors} and \emph{effect deconstructors} \autocite{plotkin_algebraic_2003}. The \el{local} and \el{catch} operations have to act on effectful computations and change the meaning of the effects in that computation. So, they have to deconstruct the effects in their computations.

% However, \olocal cannot be defined as an algebraic operation, meaning that we cannot write a handler for it, it can only be defined as a handler. This is known as the \emph{modularity problem} with higher-order effects \autocite{wu_effect_2014}.

\section{Elaborations}\label{sec:elab}

\TODO{Move this somewhere else}

Several solutions to the modularity problem have been proposed \autocite{wu_effect_2014,oh_latent_2021}. Most recently, \textcite{bach_poulsen_hefty_2023} introduced hefty algebras. The idea behind hefty algebras is that there is an additional layer of modularity, specifically for higher-order effects. The higher-order operations are not algebraic, but they can be \emph{elaborated} into algebraic operations.

A computation with higher-order effects is then first elaborated into a computation with only algebraic effects. The remaining algebraic effects can then in turn be handled to yield the result of the computation.

The advantage of hefty algebras over previous approaches is that the elaboration step is quite simple\feedback{This needs explanation} and that the result is a computation with regular algebraic effects.

Continuing the \olocal example, we can make an elaboration based on the definition above\feedback{which definition?}:
\begin{align*}
    eLocal \quad\defeq\quad
        &\elaboration\ \{ \\
        &\quad\olocal!(f, m) \mapsto \S{v \gets \oask()\seq \handle[hAsk(f(v))]\ m }\\
        &\},
\end{align*}
We can then apply this elaboration to an expression with the \elab keyword\feedback{language we're working in is unclear}, similarly to \handle:
\begin{align*}
    &\handle[hAsk(5)]\ \elab[eLocal]\ \{ \\
    &\quad x \gets \oask();\\
    &\quad y \gets \olocal!(\lambda x.\ 2\cdot x, \S{ \oask() });\\
    &\quad x + y \\
    &\}
\end{align*}

After the elaboration step, the computation will be elaborated into the program below, which will evaluate to $15$.
\begin{align*}
    &\handle[hAsk(5)]\ \{ \\
    &\quad x \gets \oask();\\
    &\quad y \gets \{\\
    &\quad\quad v \gets \oask();\\
    &\quad\quad \handle[hAsk((\lambda x.\ 2\cdot x)(v))]\ \oask()\\
    &\quad\};\\
    &\quad x + y \\
    &\}
\end{align*}

Throughout this thesis we will write elaborated higher-order operations with a \code{!} suffix\feedback{give example}, to distinguish them from algebraic effects.

\TODO{Add some stuff about typing for effects, i.e. effect rows.}
