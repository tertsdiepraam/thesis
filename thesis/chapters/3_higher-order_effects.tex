\chapter{Higher-Order Effects}\label{chap:higher_order}

In the previous chapter, we explained the concept of algebraic effects. Any effect that satisfies the algebraicity property is algebraic. However, many \emph{higher-order effects} are not algebraic. An effect is higher-order if one of its operations takes effectful computations as parameters \autocite{bach_poulsen_hefty_2023}. As a result, it is not possible to give modular implementations for these operations using effect handlers, like we can do for algebraic operations. This chapter details the difficulties around higher-order effects and discusses hefty algebras, the theory that Elaine is based on.

\section{Computation Parameters}

Recall that an effect in the free monad encoding is a functor over some \hs{k} with some constructors. The type \hs{k} represents the continuation of the computation. Naturally, it is possible to write a constructor with multiple parameters of type \hs{k}. For example, we could make a \hs{Branch} functor which takes a boolean and two computations. Based on the boolean value, it selects the branch to evaluate. It is essentially an \hs{if-else} expression expressed as an effect.

\begin{lst}{Haskell}
data Branch k = Branch Bool k k

branch :: Branch < f => Bool -> Free f a -> Free f a -> Free f a
branch b ifTrue ifFalse :: Do $ inj $ Branch b ifTrue ifFalse
\end{lst}
%
The important observation with this effect is that both \hs{ifTrue} and \hs{ifFalse} behave like continuations. To examine why, consider the following computation.

\begin{lst}{Haskell}
branch b (pure 0) (pure 1) >>= \x -> pure (x + 1)
\end{lst}
%
Like previously established, the \hs{>>=} operator distributes over the computation parameters. This yields the following expression.

\begin{lst}{Haskell}
branch b
  (pure 0 >>= \x -> pure (x + 1))
  (pure 1 >>= \x -> pure (x + 1))
-- which reduces to
branch b (pure 1) (pure 2)
\end{lst}
%
This computation has the same intended semantics as the original. The distribution of \hs{>>=} therefore does not change the semantics and hence the effect is algebraic. Therefore, there would be no problem encoding this effect in Haskell using the encoding in the previous chapter and, by extension, in Koka.

This is what we mean by saying that the parameters are computation-like: the continuation can be appended to the parameters without changing the semantics of the effect.

\section{Breaking Algebraicity}

For other effects, however, the intended semantics are not such that the computation parameters are continuation-like.

One such effect is the \hs{Reader} effect. Traditionally, the \hs{Reader} monad has two operations: \hs{local} and \hs{ask}. The latter functions much like the \hs{get} operation from the state effect and is algebraic. However, the \hs{local} operation is more complex. It takes two parameters, a function \hs{f} and a computation \hs{c}. The intended semantics are then that whenever \hs{ask} is used within \hs{c}, the function \hs{f} is applied to the returned value.

\begin{lst}{Haskell}
data Reader a k = Ask (a -> k) | Local (a -> a) k k

ask       = Do $ inj $ Get Pure
local f c = Do $ inj $ Local f c (Pure ())
\end{lst}
%
To see why the \hs{local} operation breaks algebraicity, consider the following computation.

\begin{lst}{Haskell}
local (* 2) ask >>= \x -> ask >>= \y -> pure x + y
\end{lst}
%
Only the first \hs{ask} operation is inside the \hs{local} operation and should therefore be doubled. If the \hs{Reader} effect was algebraic, we should be able to distribute the \hs{>>=} operator again without changing the semantics of the program. However, doing so yields the following computation.

\begin{lst}{Haskell}
local (* 2) (ask >>= \x -> ask >>= \y -> pure x + y)
\end{lst}
%
Now, both \hs{ask} operations are inside the \hs{local} operation, so both values will be doubled. For example, if we had installed a handler that makes \hs{ask} return 1, the first computation would return $2 + 1 = 3$ and the second $2 + 2 = 4$. Therefore, we have shown with a counterexample that the \hs{Reader} effect cannot be algebraic.

A similar argument holds for the \hs{Except} effect, which also has two operations: \hs{catch} and \hs{throw}. In the simplest form, \hs{throw} resembles the \hs{abort} effect, but it takes a parameter that represents an error message. The \hs{catch} operation evaluates its first parameter and jump to the second if it fails, much like the try-catch constructs of languages with effects.

\begin{lst}{Haskell}
data Except a k = Throw a | Catch k k

throw     = Do $ inj $ Throw
catch a b = Do $ inj $ Catch a b
\end{lst}
%
Again, we take a simple example program to show that \hs{Except} violates algebraicity.

\begin{lst}{Haskell}
catch (pure False)  (pure True) >>= throw -- -> throws False
-- then distributing >>= yields
catch
  (pure False >>= throw)
  (pure True >>= throw)
-- which simplifies to
catch (throw False) (throw True)          -- -> throws True
\end{lst}
%
Before distributing the \hs{>>=} operator the computation should throw \hs{False}, but after it should throw \hs{True}. So, again, the semantics have changed by distributing the \hs{>>=} and therefore \hs{Except} is not algebraic.

\section{The Modularity Problem}

Taking a step back from effects, defining a function for exception catching is possible. Recall that the \hs{throw} operation is algebraic, therefore, a handler for it can be defined. If we assume some handler for it called \hs{handleThrow} returns an \hs{Either} where \hs{Left} is the value from \hs{throw} and \hs{Right} is the value from a completed computation, we can define \hs{catch} in terms of that function.

\begin{lst}{Haskell}
catch c1 c2 =
  case handleThrow c1 of
    Left e -> c2
    Right a -> pure a
\end{lst}
%
The distinction between effects which are and which are not algebraic has been described as the difference between \emph{effect constructors} and \emph{effect deconstructors} \autocite{plotkin_algebraic_2003}. The \el{local} and \el{catch} operations have to act on effectful computations and change the meaning of the effects in that computation. So, they have to deconstruct the effects in their computations using handlers. An imperfect heuristic for whether a function can be an algebraic effect is to check whether the implementation requires a handler. If it uses a handler, it probably cannot be an algebraic effect.

An algebraic effect can have a modular implementation: a computation can be reused in different contexts by using different handlers. For these higher-order effects such as \hs{catch} and \hs{local}, this is not possible. This is known as the \emph{modularity problem} with higher-order effects \autocite{wu_effect_2014}. This is the motivation behind the research on higher-order effects, including this thesis. It is also the problem that the theory of hefty algebras aims to solve.

\section{Hefty Algebras}\label{sec:hefty_algebras}

Several solutions to the modularity problem have been proposed \autocite{wu_effect_2014,oh_latent_2021}. Most recently, \textcite{bach_poulsen_hefty_2023} introduced a solution called hefty algebras. The idea behind hefty algebras is that there is an additional layer of modularity, specifically for higher-order effects.

For a full treatment of hefty algebras, we refer to \textcite{bach_poulsen_hefty_2023}. In addition, the encoding of hefty algebras is explained in more detail by \textcite{bach_poulsen_algebras_2023}.

At the core of hefty algebras are hefty trees. A hefty tree is a generalization of the free monad to higher-order functors, which will write \hs{HOFunctor}. In the listing below, we also repeat the definition of a functor from the previous chapter for comparison.

\begin{lst}{Haskell}
-- a regular functor
class Functor f where
  fmap :: (a -> b) -> f a -> f b

-- a higher-order functor
class (forall f. Functor (h f)) => HOFunctor h where
  hmap :: (f a -> g a) -> (h f a -> h g a)
\end{lst}
%
The definition of a hefty tree, with the free monad for reference, then becomes:

\begin{lst}{Haskell}
-- free monad
data Free f a
  = Pure a
  | Do (f (Free f a))

-- hefty tree
data Hefty h a
  = Return a
  | Do (h (Hefty h) (Hefty h a))
\end{lst}
%
A hefty tree and a free monad are very similar: we can define the \hs{>>=}, \hs{<} and \hs{+} operators from the previous chapter for hefty trees, so that the hefty tree can be used in the same way.\footnote{We are abusing Haskell's syntax here. In the real Haskell encoding, these operators need to have different names from their free monad counterparts, for example \hs{:+} and \hs{:<}.} We refer to \textcite{bach_poulsen_hefty_2023} for the definition of these operators. Furthermore, any functor can be lifted to a higher-order functor with a \hs{Lift} data type.

\begin{lst}{Haskell}
data Lift f (m :: * -> *) k = Lift (f k)
  deriving Functor

instance Functor f => HOFunctor (Lift f) where
  hmap _ (Lift x) = Lift x
\end{lst}
%
In algebraic effects, the evaluation of a computation can be thought of as a transformation of the free monad to the final result: 
\[
    \mcode{Free f a} \quad\xrightarrow{handle}\quad \mcode{b}.
\]
Using hefty algebras, the evaluation instead starts with a \emph{hefty tree}, which is \emph{elaborated} into the free monad. The full evaluation of a computation using hefty algebras then becomes:
\[
    \mcode{Hefty h a} \quad\xrightarrow{elaborate}\quad \mcode{Free f a} \quad\xrightarrow{handle}\quad \mcode{b}.
\]
This elaboration is a transformation from a hefty tree into the free monad, defined as an algebra over hefty trees. The algebras are then used in \hs{hfold}; a fold over hefty trees.

\begin{lst}{Haskell}
hfold :: HOFunctor h
      => (forall a. a -> g a)
      -> (forall a. h g (g a) -> g a)
      -> Hefty h a 
      -> g a
hfold gen _   (Return x) = gen x
hfold gen alg (Do x)     =
  ha alg (fmap (hfold gen alg) (hmap (hfold gen alg) x))

elab :: HOFunctor h
     => (forall a. h (Free f) (Free f a) -> Free f a)
     -> Hefty h a
     -> Free f a
elab elabs = hfold Pure elabs
\end{lst}
%
For any algebraic -- and thus lifted -- effect, this elaboration is trivially defined by unwrapping the \hs{Lift} constructor.

\begin{lst}{Haskell}
elabLift :: g < f => Lift g (Free f) (Free f a) -> Free f a
elabLift (Lift x) = Op (inj x)
\end{lst}
%
Applying \hs{elabLift} to \hs{elab} then gives a function which elaborates \hs{Hefty (Lift f) a} to \hs{Free f a} for any functor \hs{f}. The more interesting case is that of higher-order effects. For example, the \hs{local} operation of the \hs{Reader} effect can be mapped to a computation using the free monad as well, resembling the definition of \hs{local} as a function.

\begin{lst}{Haskell}
data Reader r k = Local r k k

elabReader :: Ask r < f
           => Reader r (Free f) (Free f a)
           -> Free f a
elabReader (Local f m k) = ask >>= \r -> handle (hAsk (f r)) m >>= k
\end{lst}
%
The \hs{elabReader} elaboration can then be used to elaborate higher-order effects in a computation. This makes the \hs{local} operation modular, because we can define different elaborations to apply to different sub-computations. This applies to any higher-order effect we define and that is how hefty algebras solve the modularity problem.

These elaborations can be composed to construct elaborations for multiple effects as well. \textcite{bach_poulsen_hefty_2023} do this by introducing an operator \hs{^} which composes elaborations. This operator is commutative and associative. The composed elaborations are then applied all at once. 

Moreover, all elaborations must be applied at once, because elaboration transforms a \hs{Hefty h a} to a \hs{Free f a} and a \hs{Free f a} cannot contain any higher-order effects. Therefore, there cannot be any higher-order effects left in the computation after elaboration.

We found this constraint to be limiting in practice. Imagine a program with elaborations \hs{eCatch} and \hs{eReader}, for the catch and reader effect, respectively. If \hs{a} and \hs{b} and both computations that use both effects, these elaborations can be applied as follows.

\begin{lst}{Haskell}
main = handleThrow $ handleAsk 0 $
  elab (eCatch ^ eReader) (a >>= b)
\end{lst}
%
Now, we introduce a second elaboration \hs{eCatch'}, which we want to apply to \hs{b}, but not to \hs{a}. Therefore, we might be tempted to write some like this:

\begin{lst}{Haskell}
-- Not valid in hefty algebras!
main = handleThrow $ handleAsk 0 $
  elab eReader $
    (elab eCatch a) >>= (elab eCatch' b)
\end{lst}
%
However, this does not work, because the argument for the reader elaboration should be a hefty tree, not a free monad. Therefore, the only way hefty algebras allow us to do so is by elaborating the reader effect in \hs{a} and \hs{b} separately.

\begin{lst}{Haskell}
main = handleThrow $ handleAsk 0 $
  (elab (eCatch ^ eReader) a)
    >>= (elab (eCatch' ^ eReader) b)
\end{lst}
%
However, now the elaboration for the reader effect needs to be repeated. With algebraic effects, handlers can be applied for each effect individually, which can be convenient for applying different handlers to different effects.

Because applying single elaborations is so useful, Elaine's type checker and interpreter do allow it. We conjecture that these semantics still correspond to hefty algebras. However, a proof of this conjecture is left to future work. Apart from this deviation, Elaine follows the framework of hefty algebras closely.

\section{Effect Rows from Hefty Trees}
\newcommand\BB[1]{\left\llbracket\mcode{#1}\right\rrbracket}

Recall that Koka has a syntax for effect rows which corresponds to the free monad:
\[
  \BB{() -> e a}
  \qquad=\qquad
  \mcode{() -> Free}\ \BB{e}\ \BB{a}.
\]
To represent effect rows in Elaine, this concept has be generalized to hefty trees. Therefore, Elaine's effect rows correspond to higher-order functors:
\[
  \BB{() -> e a}
  \qquad\sim\qquad
  \mcode{() -> Hefty}\ \BB{e}\ \BB{a}.
\]
However, any algebraic effect needs to be lifted to be represented in a hefty tree. So, to make it easier to mix algebraic and higher-order effects, we therefore lift algebraic effects implicitly. In Elaine, all higher-order effects are suffixed with \hs{!}, so all effects without a \el{!} suffix are lifted. Consequently, for some higher-order effect \el{H!} and algebraic effect \el{A}, we have the following correspondence:
\[
  \BB{() -> <A,H!> b}
  \qquad\sim\qquad
  \mcode{() -> Hefty (Lift}
    \ \BB{A}
    \ \mcode{+}
    \ \BB{H}
    \mcode{)}
    \ \BB{b}.
\]
Like the effect rows for algebraic effects, extensions are supported as well. Conceptually the extension operator corresponds to the \hs{+} for higher-order effects:
\[
  \BB{() -> <A|e> b}
  \qquad=\qquad
  \mcode{() -> Hefty (Lift}
    \ \BB{A}
    \ \mcode{+}
    \ \BB{e}\mcode{)}
    \ \BB{b}.
\]
This is an unambiguous yet concise representation of the effect row containing any combination of algebraic and higher-order effects. This notation for effect rows is used for Elaine's types. 

\TODO{Effect row with only algebraic effects is Free but implicitly lifted to Hefty whenever necessary?}