mod Main {
    effect !Baz {
        bob(): ()
    }

    handler baz: a !Baz -> a {
        ...
    }

    effect !!Foo {
        # Type row variables stand for multiple effects. Or from another
        # perspective, they are a local alias for the rest of the effect row.
        bar(a: () !a): ()
    }

    elaboration foo: a !!Foo -> a !Baz {
        bar(a: () !a): () {
            b <- handle baz {
                a
            }
            b
        }
    }

    # What should happen here?
    # Well we have the following context:
    #
    #  - Identifiers: {!Baz, !!Foo, foo, main, bar, bob}
    #  - Higher-order effects: {!!Foo -> [bar]}
    #  - Elaborations: {foo: !!Foo -> a !Baz}
    #  
    # Steps:
    #
    # 1. Find the higher-order operations appearing in the computation within
    #    `elab`: {bar}
    # 2. Find the relevant effects: {!!Foo}
    # 3. Look for elaborations of !!Foo: {foo}
    # 4. If none: type-error, if multiple: type-error
    # 5. If exactly 1: rewrite to explicit elaboration
    # 6. Bonus: compile the elaboration away before execution? This might
    #    require some monomorphization-like techniques but should be possible.
    #
    # In this case, it's all happening at identifier level, which is not great.
    # In reality, all identifiers in this example need to be prefixed by the
    # name of the module in which they were defined for this to be correct.
    #
    # I'm also ignoring type parameters.
    fn main(): () {
        handle baz {
            elab {
                bar({
                    ()
                })
            }
        }
    }
}